#Java 상속

## 상속

상속은 부모가 자식에게 물려주는 행위를 말한다. 객체 지향 프로그램에서도 부모 클래스의 필드와 메소드를 자식 클래스에게 물려줄 수 있다
상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 중복되는 코드를 줄여 개발 시간을 단축시킨다.

public class A{
  int field1;
  void method1(){...}
}

public class B extends A { // A를 상속
  String field2;
  void method2() {.....}
}

B b = new B();
b.field1 = 10;
b.method1();  // A로부터 물려받은 필드와 메소드

b.field2 = "홍길동";
method2; // B가 추가한 필드와 메소드

상속의 또다른 이점은 클래스의 수정을 최소화할 수 있다는 것이다. 부모 클래스를 수정하면 모든 자식 클래스에게 수정 효과를 가져온다. 예를 들어 B,C가 A를 상속한 경우, A의 필드와 메소드를 수정하면 B,C를 수정하지 않아도
수정된 A의 필드와 메소드를 이용할 수 있다.

## 클래스 상속

자식 클래스를 선언할 때 어떤 부모로부터 상속 받을 것인지를 결정하고, 부모 클래스를 다음과 같이 extends 뒤에 기술한다.

pubic class 자식 클래스 extends 부모 클래스{
}

다른 언어와 달리 자바는 다중 상속을 하용하지 않는다. 여러개의 부모클래스를 상속할 수 없다. 따라서 extends 뒤에는 단 하나의 부모클래스만이 와야한다.

public class 자식 클래스 extends 부모클래스1, 부모클래스2(X) { // 다중 상속 불가
}

## 부모 생성자 호출

자식 객체를 생성하면 부모 객체가 먼저 생성된 다음 자식 객체가 생성된다. 모든 객체는 생성자를 호출해야만 생성된다. 그렇다면 부모객체의 생성자는 어디서 호출된 것일까? 이것에 대한 비밀은 자식 생성자에 숨어 있다.
부모 생성자는 자식 생성자의 맨 첫 줄에 숨겨져 있는 super()에 의해 호출된다.

//자식 생성자 선언
public 자식클래스(...){
  super();
}

super()는 컴파일 과정에서 자동 추가되는데 이것은 부모의 기본 생성자를 호출한다. 만약 부모 클래스에 기본 생성자가 없다면 자식 생성자 선언에서 컴파일 에러가 발생한다.
부모 클래스에 기본 생성자가 없고 매개변수를 갖는 생성자만 있다면 개발자는 다음과 같이 super(매개값...) 코드를 직접 넣어야한다. 이 코드는 매개값의 타입과 개수가 일치하는 부모 생성자를 호출한다.

public 자식 클래스(){
  super(매개값,...);
}

## 매소드 재정의

부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수 있다. 이러한 메소드는 자식 클래스에서 재정의해서 사용해야한다.
이를 메소드 오버라이딩(overriding)이라고 한다.

### 메소드 오버라이딩

메소드 오버라이딩은 상속된 메소드를 자식 클래스에서 재정의하는 것을 말한다. 메소드 오버라이딩이 되었다면 해당 부모 메소드는 숨겨지고 자식 메소드가 우선적으로 사용된다.
메소드를 오버라이딩 할 때는 다음 규칙에 주의해서 작성해야한다.

* 부모 메소드의 선언부(리턴타입, 메소드 이름, 매개변수)와 동일해야한다.
* 접근 제한을 더 강하게 오버라이딩할 수 없다.(public -> private 변경 불가)
* 새로운 예외를 throws할 수 없다.

### 부모 메소드 호출

메소드를 재정의하면 부모 메소드는 숨겨지고 자식 메소드만 사용되기 때문에 비록 부모 메소드의 일부만 변경된다 하더라도 중복된 내용을 자식 메소드도 가지고 있어야한다.
예를 들어 부모메소드가 100줄의 코드를 가지고 있을 경우 자식 메소드에서 1줄을 추가하고 싶더라도 100줄의 코드를 자식 메소드에서 다시 작성해야한다.
이 문제는 자식 메소드가 부모 메소드를 호출하는 것으로 해결할 수 있다. super 키워드와 도트(.)연산자를 사용하면 숨겨진 부모메소드를 호출할 수 있다.

class Parent{
  public void method(){
  }
}

class Child extends Parent{
  @Overriding
  public void method(){
    super.method();
  } // 재정의된 메소드
}

## final 클래스와 final 메소드

### final 클래스

클래스를 선언 할 때 final 키워드를 class 앞에 붙이면 최종적인 클래스가 되므로 더 이상 상속할 수 없는 클래스가 된다. 즉 final클래스는 부모 클래스가 될 수 없어저 자식 클래스를 만들 수 없다.

public final class 클래스{...}

대표적인 예가 String 클래스이다. String 클래스는 다음과 같이 선언되어 있다.

public final class String {....}

### final 메소드

메소드를 선언 할 때 final 키워드를 붙이면 이 메소드는 최종적인 메소드이므로 오버라이딩할 수 없는 메소드가 된다. 즉 부모클래스를 상속해서 자식 클래스를 선언할 때
부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의 할 수 없다.

public final 리턴타입 메소드(매개변수, .....) { ...... }

